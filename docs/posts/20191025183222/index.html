<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.59.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Clericpy" />
  <meta property="og:url" content="https://clericpy.github.io/blog/posts/20191025183222/" />
  <link rel="canonical" href="https://clericpy.github.io/blog/posts/20191025183222/" /><link rel="shortcut icon" href="favicon.ico" type="image/x-png" /><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/clericpy.github.io\/blog\/"
      },
      "articleSection" : "posts",
      "name" : "爬虫常用代码片段合集 - [torequests.utils]",
      "headline" : "爬虫常用代码片段合集 - [torequests.utils]",
      "description" : "Spider needs HTTP, more than HTTP.",
      "inLanguage" : "en-US",
      "author" : "Clericpy",
      "creator" : "Clericpy",
      "publisher": "Clericpy",
      "accountablePerson" : "Clericpy",
      "copyrightHolder" : "Clericpy",
      "copyrightYear" : "2019",
      "datePublished": "2019-10-25 18:32:22 \x2b0800 CST",
      "dateModified" : "2019-10-25 18:32:22 \x2b0800 CST",
      "url" : "https:\/\/clericpy.github.io\/blog\/posts\/20191025183222\/",
      "keywords" : [  ]
  }
</script>
<title>爬虫常用代码片段合集 - [torequests.utils] - Clericpy&#39;s Blog</title>
  <meta property="og:title" content="爬虫常用代码片段合集 - [torequests.utils] - Clericpy&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="Spider needs HTTP, more than HTTP." />

  <link rel="stylesheet" href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/tomorrow.min.css" />
  <link rel="stylesheet" href="/blog/css/index.css">
  <link href="/blog/index.xml" rel="alternate" type="application/rss+xml" title="Clericpy&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet">
  
  <script>
    

    (function (undefined) { }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  
</head>

<body>
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2 col-lg-6 col-lg-offset-3">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/blog/">Clericpy&#39;s Blog</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">爬虫常用代码片段合集 - [torequests.utils]</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-10-25 18:32:22 CST">
                25 Oct 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://github.com/ClericPy">@Clericpy</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          

<hr />

<h2 id="前言">前言</h2>

<p><del>此处省略 150 字引言, 假装以后会补.</del></p>

<h2 id="正文">正文</h2>

<p>以下功能均已收入 <a href="https://github.com/ClericPy/torequests">torequests</a></p>

<blockquote>
<p><em>pip install torequests -U</em></p>
</blockquote>

<ol>
<li><p>查看当前进程的内存占用. 借助 <strong>psutil</strong></p>

<ol>
<li><p>代码</p>

<pre><code class="language-python">def print_mem(unit=&quot;MB&quot;):
  &quot;&quot;&quot;Show the proc-mem-cost with psutil, use this only for lazinesssss.
      
  :param unit: B, KB, MB, GB.
  &quot;&quot;&quot;
  try:
      import psutil, os
      
      B = float(psutil.Process(os.getpid()).memory_info().vms)
      KB = B / 1024
      MB = KB / 1024
      GB = MB / 1024
      result = vars()[unit]
      print(&quot;memory usage: %.2f(%s)&quot; % (result, unit))
      return result
  except ImportError:
      print(&quot;pip install psutil first.&quot;)
      
      
print_mem()  # memory usage: 8.93(MB)
</code></pre></li>
</ol></li>

<li><p>将 cURL 命令转为人类可读的 dict 参数, 兼容 requests.request</p>

<ol>
<li><p>使用原始请求的好处</p>

<ol>
<li>不会因为遗漏请求参数而导致请求失败, 比如 Referer, User-Agent, Accept 等</li>
<li>解析结果可以直接使用 requests.request(**result) 来发出请求</li>
</ol></li>

<li><p>code</p>

<pre><code class="language-python">import shlex
import argparse
      
      
class _Curl:
  &quot;&quot;&quot;Curl args parser.
      
  **Use curlparse function directly.**
  &quot;&quot;&quot;
      
  parser = argparse.ArgumentParser()
  parser.add_argument(&quot;curl&quot;)
  parser.add_argument(&quot;url&quot;)
  parser.add_argument(&quot;-X&quot;, &quot;--method&quot;, default=&quot;get&quot;)
  parser.add_argument(&quot;-A&quot;, &quot;--user-agent&quot;)
  parser.add_argument(&quot;-u&quot;, &quot;--user&quot;)  # &lt;user[:password]&gt;
  parser.add_argument(&quot;-x&quot;, &quot;--proxy&quot;)  # proxy.com:port
  parser.add_argument(&quot;-d&quot;, &quot;--data&quot;)
  parser.add_argument(&quot;-F&quot;, &quot;--form&quot;)
  parser.add_argument(&quot;--data-binary&quot;)
  parser.add_argument(&quot;--connect-timeout&quot;, type=float)
  parser.add_argument(
      &quot;-H&quot;, &quot;--header&quot;, action=&quot;append&quot;, default=[])  # key: value
  parser.add_argument(&quot;--compressed&quot;, action=&quot;store_true&quot;)
      
      
def curlparse(string, encoding=&quot;utf-8&quot;):
  &quot;&quot;&quot;Translate curl-string into dict of request.
      :param string: standard curl-string, like `r'''curl ...'''`.
      :param encoding: encoding for post-data encoding.
      
  Basic Usage::
      
    &gt;&gt;&gt; from torequests.utils import curlparse
    &gt;&gt;&gt; curl_string = '''curl 'https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0' -H 'Pragma: no-cache' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: zh-CN,zh;q=0.9' -H 'Upgrade-Insecure-Requests: 1' -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: no-cache' -H 'Referer: https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0' -H 'Cookie: ASPSESSIONIDSQRRSADB=MLHDPOPCAMBDGPFGBEEJKLAF' -H 'Connection: keep-alive' --compressed'''
    &gt;&gt;&gt; request_args = curlparse(curl_string)
    &gt;&gt;&gt; request_args
    {'url': 'https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0', 'headers': {'Pragma': 'no-cache', 'Dnt': '1', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Cache-Control': 'no-cache', 'Referer': 'https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0', 'Cookie': 'ASPSESSIONIDSQRRSADB=MLHDPOPCAMBDGPFGBEEJKLAF', 'Connection': 'keep-alive'}, 'method': 'get'}
    &gt;&gt;&gt; import requests
    &gt;&gt;&gt; requests.request(**request_args)
    &lt;Response [200]&gt;
  &quot;&quot;&quot;
  assert &quot;\n&quot; not in string, 'curl-string should not contain \\n, try r&quot;...&quot;.'
  if string.startswith(&quot;http&quot;):
      return {&quot;url&quot;: string, &quot;method&quot;: &quot;get&quot;}
  try:
      lex_list = shlex.split(string.strip())
  except ValueError as e:
      if str(e) == 'No closing quotation' and string.count(&quot;'&quot;) % 2 != 0:
          print_info(
              &quot;If `data` has single-quote ('), the `data` should be quote by double-quote, and add the `backslash`(\\) before original \&quot;.&quot;
          )
      raise e
  args, unknown = _Curl.parser.parse_known_args(lex_list)
  requests_args = {}
  headers = {}
  requests_args[&quot;url&quot;] = args.url
  for header in args.header:
      key, value = header.split(&quot;:&quot;, 1)
      headers[key.title()] = value.strip()
  if args.user_agent:
      headers[&quot;User-Agent&quot;] = args.user_agent
  if headers:
      requests_args[&quot;headers&quot;] = headers
  if args.user:
      requests_args[&quot;auth&quot;] = tuple(
          u for u in args.user.split(&quot;:&quot;, 1) + [&quot;&quot;])[:2]
  # if args.proxy:
  # pass
  data = args.data or args.data_binary or args.form
  if data:
      if data.startswith(&quot;$&quot;):
          data = data[1:]
      args.method = &quot;post&quot;
      if PY2:
          # TODO not fix the UnicodeEncodeError, so use `replace`, damn python2.x.
          data = data.replace(r'\r', '\r').replace(r'\n', '\n')
      else:
          data = data.encode(
              'latin-1',
              'backslashreplace').decode('unicode-escape').encode(encoding)
      requests_args[&quot;data&quot;] = data
  requests_args[&quot;method&quot;] = args.method.lower()
  if args.connect_timeout:
      requests_args[&quot;timeout&quot;] = args.connect_timeout
  return requests_args
      
      
print(
  curlparse(
      r'''curl 'https://httpbin.org/get' -H 'Connection: keep-alive' -H 'Cache-Control: max-age=0' -H 'DNT: 1' -H 'Upgrade-Insecure-Requests: 1' -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36' -H 'Sec-Fetch-User: ?1' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3' -H 'Sec-Fetch-Site: none' -H 'Sec-Fetch-Mode: navigate' -H 'Accept-Encoding: gzip, deflate, br' -H 'Accept-Language: zh-CN,zh;q=0.9' --compressed'''
  ))
# {'url': 'https://httpbin.org/get', 'headers': {'Connection': 'keep-alive', 'Cache-Control': 'max-age=0', 'Dnt': '1', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36', 'Sec-Fetch-User': '?1', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Sec-Fetch-Site': 'none', 'Sec-Fetch-Mode': 'navigate', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9'}, 'method': 'get'}
</code></pre></li>
</ol></li>

<li><p>将多个可迭代对象合并成一个生成器</p>

<ol>
<li><p>Python3 中已经默认实现</p>

<ol>
<li>&gt; from itertools import chain</li>
</ol></li>

<li><p>code</p>

<pre><code class="language-python">def itertools_chain(*iterables):
  &quot;&quot;&quot;For the shortage of Python2's, Python3: `from itertools import chain`.&quot;&quot;&quot;
  for it in iterables:
      for element in it:
          yield element
</code></pre></li>
</ol></li>

<li><p>将一个序列均分成 n 等份 &amp; 将一个序列按照长度 n 等分</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">from itertools import chain as itertools_chain
      
      
def slice_by_size(seq, size):
  &quot;&quot;&quot;Slice a sequence into chunks, return as a generation of chunks with `size`.  &quot;&quot;&quot;
  filling = object()
  for it in zip(*(itertools_chain(seq, [filling] * size),) * size):
      if filling in it:
          it = tuple(i for i in it if i is not filling)
      if it:
          yield it
      
      
def slice_into_pieces(seq, n):
  &quot;&quot;&quot;Slice a sequence into `n` pieces, return a generation of n pieces&quot;&quot;&quot;
  length = len(seq)
  if length % n == 0:
      size = length // n
  else:
      size = length // n + 1
  for it in slice_by_size(seq, size):
      yield it
      
      
n = 3
items = list(range(10))
chunks = slice_by_size(items, n)
print(list(chunks))
# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]
chunks = slice_into_pieces(items, n)
print(list(chunks))
# [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9)]
# ==================================
# 不在乎性能, slice_by_size 也可以使用如下简单的写法
chunks = (items[i:i + n] for i in range(0, len(items), n))
print(list(chunks))
# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
</code></pre></li>
</ol></li>

<li><p>简单地根据时区处理 时间戳 ↔ 当地时间</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">import time
      
TIMEZONE = int(-time.timezone / 3600)
      
      
def ttime(timestamp=None, tzone=None, fail=&quot;&quot;, fmt=&quot;%Y-%m-%d %H:%M:%S&quot;):
  &quot;&quot;&quot;Translate timestamp into human-readable: %Y-%m-%d %H:%M:%S.
      
  :param timestamp: the timestamp float, or `time.time()` by default.
  :param tzone: time compensation, int(-time.timezone / 3600) by default,
              (can be set with TIMEZONE).
  :param fail: while raising an exception, return it.
  :param fmt: %Y-%m-%d %H:%M:%S, %z not work.
  :rtype: str
      
  &gt;&gt;&gt; ttime()
  2018-03-15 01:24:35
  &gt;&gt;&gt; ttime(1486572818.421858323)
  2017-02-09 00:53:38
  &quot;&quot;&quot;
  tzone = TIMEZONE if tzone is None else tzone
  fix_tz = tzone * 3600
  if timestamp is None:
      timestamp = time.time()
  else:
      timestamp = float(timestamp)
      if 1e12 &lt;= timestamp &lt; 1e13:
          # Compatible timestamp with 13-digit milliseconds
          timestamp = timestamp / 1000
  try:
      timestamp = time.time() if timestamp is None else timestamp
      return time.strftime(fmt, time.gmtime(timestamp + fix_tz))
  except:
      return fail
      
      
def ptime(timestr=None, tzone=None, fail=0, fmt=&quot;%Y-%m-%d %H:%M:%S&quot;):
  &quot;&quot;&quot;Translate %Y-%m-%d %H:%M:%S into timestamp.
      
  :param timestr: string like 2018-03-15 01:27:56, or time.time() if not set.
  :param tzone: time compensation, int(-time.timezone / 3600) by default,
              (can be set with TIMEZONE).
  :param fail: while raising an exception, return it.
  :param fmt: %Y-%m-%d %H:%M:%S, %z not work.
  :rtype: int
      
      &gt;&gt;&gt; ptime('2018-03-15 01:27:56')
      1521048476
  &quot;&quot;&quot;
  tzone = TIMEZONE if tzone is None else tzone
  fix_tz = -(tzone * 3600 + time.timezone)
  #: str(timestr) for datetime.datetime object
  timestr = str(timestr or ttime())
  try:
      return int(time.mktime(time.strptime(timestr, fmt)) + fix_tz)
  except:
      return fail
      
      
# 当地时间的当前时间
print(ttime())  # 2019-10-25 19:12:59
# 0 时区的当前时间
print(ttime(tzone=0))  # 2019-10-25 11:12:59
# 当地时间的当前时间戳
print(ptime())  # 1572001979
print(ptime(ttime()))  # 1572001979
</code></pre></li>
</ol></li>

<li><p>将单位秒的数字转化成人类可读的字符串或字典</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">import time
      
      
def split_seconds(seconds):
  &quot;&quot;&quot;Split seconds into [day, hour, minute, second, ms]
      
      `divisor: 1, 24, 60, 60, 1000`
      
      `units: day, hour, minute, second, ms`
      
  &gt;&gt;&gt; split_seconds(6666666)
  [77, 3, 51, 6, 0]
  &quot;&quot;&quot;
  ms = seconds * 1000
  divisors = (1, 24, 60, 60, 1000)
  quotient, result = ms, []
  for divisor in divisors[::-1]:
      quotient, remainder = divmod(quotient, divisor)
      result.append(quotient) if divisor == 1 else result.append(remainder)
  return result[::-1]
      
      
def timeago(seconds=0, accuracy=4, format=0, lang=&quot;en&quot;):
  &quot;&quot;&quot;Translate seconds into human-readable.
      
      :param seconds: seconds (float/int).
      :param accuracy: 4 by default (units[:accuracy]), determine the length of elements.
      :param format: index of [led, literal, dict].
      :param lang: en or cn.
      :param units: day, hour, minute, second, ms.
      
  &gt;&gt;&gt; timeago(93245732.0032424, 5)
  '1079 days, 05:35:32,003'
  &gt;&gt;&gt; timeago(93245732.0032424, 4, 1)
  '1079 days 5 hours 35 minutes 32 seconds'
  &gt;&gt;&gt; timeago(-389, 4, 1)
  '-6 minutes 29 seconds 0 ms'
  &quot;&quot;&quot;
  assert format in [0, 1,
                    2], ValueError(&quot;format arg should be one of 0, 1, 2&quot;)
  negative = &quot;-&quot; if seconds &lt; 0 else &quot;&quot;
  seconds = abs(seconds)
  if lang == &quot;en&quot;:
      units = (&quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;, &quot;ms&quot;)
  elif lang == &quot;cn&quot;:
      units = (u&quot;天&quot;, u&quot;小时&quot;, u&quot;分钟&quot;, u&quot;秒&quot;, u&quot;毫秒&quot;)
  times = split_seconds(seconds)
  if format == 2:
      return dict(zip(units, times))
      
  day, hour, minute, second, ms = times
      
  if format == 0:
      day_str = (&quot;%d %s%s, &quot; % (day, units[0],
                                &quot;s&quot; if day &gt; 1 and lang == &quot;en&quot; else &quot;&quot;)
                 if day else &quot;&quot;)
      mid_str = &quot;:&quot;.join((&quot;%02d&quot; % i for i in (hour, minute, second)))
      if accuracy &gt; 4:
          mid_str += &quot;,%03d&quot; % ms
      return negative + day_str + mid_str
  elif format == 1:
      # find longest valid fields index (non-zero in front)
      valid_index = 0
      for x, i in enumerate(times):
          if i &gt; 0:
              valid_index = x
              break
      else:
          valid_index = x
      result_str = [
          &quot;%d %s%s&quot; % (num, unit, &quot;s&quot;
                       if lang == &quot;en&quot; and num &gt; 1 and unit != &quot;ms&quot; else &quot;&quot;)
          for num, unit in zip(times, units)
      ][valid_index:][:accuracy]
      result_str = &quot; &quot;.join(result_str)
      return negative + result_str
      
      
print(split_seconds(6666666.66))
# [77.0, 3.0, 51.0, 6.0, 660.0]
print(timeago(93245732.0032424, 5))
# 1079 days, 05:35:32,003
print(timeago(93245732.0032424, 4, 1))
# 1079 days 5 hours 35 minutes 32 seconds
print(timeago(-389, 4, 1))
# -6 minutes 29 seconds 0 ms
print(timeago(-389, 4, 1, 'cn'))
# -6 分钟 29 秒 0 毫秒
</code></pre></li>
</ol></li>

<li><p>将一个对象转为字符串, 用 utf-8 编码, 并取其 md5</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">import hashlib
      
if not isinstance(range(1), list):
  # python3
  unicode = str
      
      
def md5(string, n=32, encoding=&quot;utf-8&quot;, skip_encode=False):
  &quot;&quot;&quot;str(obj) -&gt; md5_string
      
  :param string: string to operate.
  :param n: md5_str length.
      
  &gt;&gt;&gt; from torequests.utils import md5
  &gt;&gt;&gt; md5(1, 10)
  '923820dcc5'
  &gt;&gt;&gt; md5('test')
  '098f6bcd4621d373cade4e832627b4f6'
  &quot;&quot;&quot;
  todo = string if skip_encode else unicode(string).encode(encoding)
  if n == 32:
      return hashlib.md5(todo).hexdigest()
  elif isinstance(n, (int, float)):
      return hashlib.md5(todo).hexdigest()[(32 - n) // 2:(n - 32) // 2]
  elif isinstance(n, (tuple, list)):
      return hashlib.md5(todo).hexdigest()[n[0]:n[1]]
      
      
print(md5('test'))
# 098f6bcd4621d373cade4e832627b4f6
print(md5([1, 2, 3]))
# 49a5a960c5714c2e29dd1a7e7b950741
print(md5(object))
# 6abc48afdb859b639e0a0e1edd225a99
</code></pre></li>
</ol></li>

<li><p>一个简简单单的计数器, 实际貌似没什么用&hellip;</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">      
class Counts(object):
  &quot;&quot;&quot;Counter for counting the times been called
      
  &gt;&gt;&gt; from torequests.utils import Counts
  &gt;&gt;&gt; cc = Counts()
  &gt;&gt;&gt; cc.x
  1
  &gt;&gt;&gt; cc.x
  2
  &gt;&gt;&gt; cc.now
  2
  &gt;&gt;&gt; cc.current
  2
  &gt;&gt;&gt; cc.sub()
  1
  &quot;&quot;&quot;
      
  __slots__ = (&quot;start&quot;, &quot;step&quot;, &quot;current&quot;, &quot;total&quot;)
      
  def __init__(self, start=0, step=1):
      self.start = start
      self.step = step
      self.current = start
      self.total = -1
      
  def clear(self):
      self.current = self.start
      
  @property
  def x(self):
      return self.add()
      
  @property
  def s(self):
      return self.sub()
      
  @property
  def c(self):
      return self.x
      
  @property
  def now(self):
      return self.current
      
  def add(self, num=None):
      self.current += num or self.step
      return self.current
      
  def sub(self, num=None):
      self.current -= num or self.step
      return self.current
</code></pre></li>
</ol></li>

<li><p>给序列去重并返回一个保留原始顺序的生成器.</p>

<ol>
<li><p>目前用过的最佳性能还是通过一个 seen set 来判断</p></li>

<li><p>code</p>

<pre><code class="language-python">def unique(seq, key=None, return_as=None):
  &quot;&quot;&quot;Unique the seq and keep the order.
      
  Instead of the slow way:
      `lambda seq: (x for index, x in enumerate(seq) if seq.index(x)==index)`
      
  :param seq: raw sequence.
  :param return_as: generator for default, or list / set / str...
      
  &gt;&gt;&gt; from torequests.utils import unique
  &gt;&gt;&gt; a = [1,2,3,4,2,3,4]
  &gt;&gt;&gt; unique(a)
  &lt;generator object unique.&lt;locals&gt;.&lt;genexpr&gt; at 0x05720EA0&gt;
  &gt;&gt;&gt; unique(a, str)
  '1234'
  &gt;&gt;&gt; unique(a, list)
  [1, 2, 3, 4]
  &quot;&quot;&quot;
  seen = set()
  add = seen.add
  if key:
      generator = (x for x in seq if key(x) not in seen and not add(key(x)))
  else:
      generator = (x for x in seq if x not in seen and not add(x))
  if return_as:
      if return_as == str:
          return &quot;&quot;.join(map(str, generator))
      else:
          return return_as(generator)
  else:
      # python2 not support yield from
      return generator
</code></pre></li>
</ol></li>

<li><p>通过正则表达式来注册和查找函数, 实现简易模式匹配</p>

<ol>
<li><p>简单地说, 就是通过装饰器来绑定一个函数和一段正则表达式, 之后按照字符串来找到对应函数.</p></li>

<li><p>常见用途:</p>

<ol>
<li><p>用正则表达式注册一个爬虫函数, 方便在遇到符合正则的 URL 时执行对应函数</p></li>

<li><p>HTTP server 的 route 查询</p>

<pre><code class="language-python">class Regex(object):
  &quot;&quot;&quot;Register some objects(like functions) to the regular expression.
          
  &gt;&gt;&gt; from torequests.utils import Regex, re
  &gt;&gt;&gt; reg = Regex()
  &gt;&gt;&gt; @reg.register_function('http.*cctv.*')
  ... def mock():
  ...     pass
  ...
  &gt;&gt;&gt; reg.register('http.*HELLOWORLD', 'helloworld', instances='http://helloworld', flags=re.I)
  &gt;&gt;&gt; reg.register('http.*HELLOWORLD2', 'helloworld2', flags=re.I)
  &gt;&gt;&gt; reg.find('http://cctv.com')
  [&lt;function mock at 0x031FC5D0&gt;]
  &gt;&gt;&gt; reg.match('http://helloworld')
  ['helloworld']
  &gt;&gt;&gt; reg.match('non-http://helloworld')
  []
  &gt;&gt;&gt; reg.search('non-http://helloworld')
  ['helloworld']
  &gt;&gt;&gt; len(reg.search('non-http://helloworld2'))
  2
  &gt;&gt;&gt; print(reg.show_all())
  ('http.*cctv.*') =&gt;  =&gt; &lt;class 'function'&gt; mock &quot;&quot;
  ('http.*HELLOWORLD', re.IGNORECASE) =&gt; http://helloworld =&gt; &lt;class 'str'&gt; helloworld
  ('http.*HELLOWORLD2', re.IGNORECASE) =&gt;  =&gt; &lt;class 'str'&gt; helloworld2
  &gt;&gt;&gt; reg.fuzzy('non-http://helloworld')
  [('http://helloworld', 95)]
  &quot;&quot;&quot;
          
  def __init__(self, ensure_mapping=False):
      &quot;&quot;&quot;
      :param ensure_mapping: ensure mapping one to one, if False,
       will return all(more than 1) mapped object list.&quot;&quot;&quot;
      self.container = []
      self.ensure_mapping = ensure_mapping
          
  def register(self, patterns, obj=None, instances=None, **reg_kwargs):
      &quot;&quot;&quot;Register one object which can be matched/searched by regex.
          
      :param patterns: a list/tuple/set of regex-pattern.
      :param obj: return it while search/match success.
      :param instances: instance list will search/match the patterns.
      :param reg_kwargs: kwargs for re.compile.
      &quot;&quot;&quot;
      assert obj, &quot;bool(obj) should be True.&quot;
      patterns = patterns if isinstance(patterns, (list, tuple, set)) else [patterns]
      instances = instances or []
      instances = (
          instances if isinstance(instances, (list, tuple, set)) else [instances]
      )
      for pattern in patterns:
          pattern_compiled = re.compile(pattern, **reg_kwargs)
          self.container.append((pattern_compiled, obj, instances))
          if self.ensure_mapping:
              # check all instances to avoid one-to-many instances.
              self._check_instances()
          else:
              # no need to check all instances.
              for instance in instances:
                  assert self.search(instance) == [obj] or self.match(instance) == [
                      obj
                  ], (
                      &quot;instance %s should fit at least one pattern %s&quot;
                      % (instance, pattern)
                  )
          
  def register_function(self, patterns, instances=None, **reg_kwargs):
      &quot;&quot;&quot;Decorator for register.&quot;&quot;&quot;
          
      def wrapper(function):
          self.register(patterns, function, instances=instances, **reg_kwargs)
          return function
          
      return wrapper
          
  def find(self, string, default=None):
      &quot;&quot;&quot;Return match or search result.
          
      :rtype: list&quot;&quot;&quot;
      return self.match(string) or self.search(string) or default
          
  def search(self, string, default=None):
      &quot;&quot;&quot;Use re.search to find the result
          
      :rtype: list&quot;&quot;&quot;
      default = default if default else []
      result = [item[1] for item in self.container if item[0].search(string)]
      if self.ensure_mapping:
          assert len(result) &lt; 2, &quot;%s matches more than one pattern: %s&quot; % (
              string,
              result,
          )
      return result if result else default
          
  def match(self, string, default=None):
      &quot;&quot;&quot;Use re.search to find the result
          
      :rtype: list&quot;&quot;&quot;
      default = default if default else []
      result = [item[1] for item in self.container if item[0].match(string)]
      if self.ensure_mapping:
          assert len(result) &lt; 2, &quot;%s matches more than one pattern: %s&quot; % (
              string,
              result,
          )
      return result if result else default
          
  def fuzzy(self, key, limit=5):
      &quot;&quot;&quot;Give suggestion from all instances.&quot;&quot;&quot;
      instances = [i[2] for i in self.container if i[2]]
      if not instances:
          return
      instances = sum(instances, [])
      from fuzzywuzzy import process
          
      maybe = process.extract(key, instances, limit=limit)
      return maybe
          
  def _check_instances(self):
      for item in self.container:
          for instance in item[2]:
              assert self.search(instance) or self.match(
                  instance
              ), &quot;instance %s not fit pattern %s&quot; % (instance, item[0].pattern)
          
  def show_all(self, as_string=True):
      &quot;&quot;&quot;, python2 will not show flags&quot;&quot;&quot;
      result = []
      for item in self.container:
          pattern = str(item[0])[10:] if PY3 else item[0].pattern
          instances = item[2] or []
          value = (
              '%s &quot;%s&quot;' % (item[1].__name__, (item[1].__doc__ or &quot;&quot;))
              if callable(item[1])
              else str(item[1])
          )
          value = &quot;%s %s&quot; % (type(item[1]), value)
          result.append(&quot; =&gt; &quot;.join((pattern, &quot;,&quot;.join(instances), value)))
      return &quot;\n&quot;.join(result) if as_string else result
</code></pre></li>
</ol></li>
</ol></li>

<li><p>常用 User-Agent</p>

<ol>
<li><p>code</p>

<pre><code class="language-python">class UA:
   &quot;&quot;&quot;Some common User-Agents for crawler.
       
   Android, iPhone, iPad, Firefox, Chrome, IE6, IE9&quot;&quot;&quot;
       
   __slots__ = ()
   Android = &quot;Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Mobile Safari/537.36&quot;
   iPhone = &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1&quot;
   iPad = &quot;Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&quot;
   Firefox = (
       &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;
   )
   Chrome = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&quot;
   IE6 = &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&quot;
   IE9 = &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot;
   WECHAT_ANDROID = &quot;Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) &gt; AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 &gt; Chrome/37.0.0.0 Mobile Safari/537.36 &gt; MicroMessenger/6.0.2.56_r958800.520 NetType/WIFI&quot;
   WECHAT_IOS = &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Mobile/9B176 MicroMessenger/4.3.2&quot;
</code></pre></li>
</ol></li>

<li><p>简单计时器装置, 支持装饰器, 函数闭包调用, 全局调用</p>

<ol>
<li><p>原理就是通过 sys._getframe(stack_level).f_code.co_name 拿到栈信息</p></li>

<li><p>然后默认在 delete (也就是被回收时), 打印经过的时间, 或者调用 timer.x 打印一次</p></li>

<li><p>timeit.default_timer 比 time.time 更合理</p></li>

<li><p>具体用法见类文档中的实例.</p></li>

<li><p>PS: 这个类写的时候还没有 <strong>PySnooper</strong> 这个库, 否则就会参考它里面的方式来实现, 毕竟直接在栈信息里到处转悠还是比较容易出错的.</p>

<pre><code class="language-python">class Timer(object):
   &quot;&quot;&quot;
   Usage:
       init Timer anywhere:
           such as head of function, or head of module, then it will show log after del it by gc.
       
       :param name: be used in log or None.
       :param log_func: some function to show process.
       :param default_timer: use `timeit.default_timer` by default.
       :param rounding: None, or seconds will be round(xxx, rounding)
       :param readable: None, or use `timepass`: readable(cost_seconds) -&gt; 00:00:01,234
       
       ::
       
           from torequests.utils import Timer
           import time
           Timer()
       
           @Timer.watch()
           def test(a=1):
               Timer()
               time.sleep(1)
       
               def test_inner():
                   t = Timer('test_non_del')
                   time.sleep(1)
                   t.x
       
               test_inner()
       
           test(3)
           time.sleep(1)
           # [2018-03-10 02:16:48]: Timer [00:00:01]: test_non_del, start at 2018-03-10 02:16:47.
           # [2018-03-10 02:16:48]: Timer [00:00:02]: test(a=3), start at 2018-03-10 02:16:46.
           # [2018-03-10 02:16:48]: Timer [00:00:02]: test(3), start at 2018-03-10 02:16:46.
           # [2018-03-10 02:16:49]: Timer [00:00:03]: &lt;module&gt;: __main__ (temp_code.py), start at 2018-03-10 02:16:46.
       
   &quot;&quot;&quot;
       
   def __init__(
       self,
       name=None,
       log_func=None,
       default_timer=None,
       rounding=None,
       readable=None,
       log_after_del=True,
       stack_level=1,
   ):
       readable = readable or timepass
       self._log_after_del = False
       self.start_at = time.time()
       uid = md5(&quot;%s%s&quot; % (self.start_at, id(self)))
       if not name:
           f_name = sys._getframe(stack_level).f_code.co_name
           f_local = sys._getframe(stack_level).f_locals
           if f_name == &quot;&lt;module&gt;&quot;:
               f_vars = &quot;: %s (%s)&quot; % (
                   f_local.get(&quot;__name__&quot;),
                   os.path.split(f_local.get(&quot;__file__&quot;))[-1],
               )
               # f_vars = f_vars.replace(' __main__', '')
           else:
               f_vars = (
                   &quot;(%s)&quot;
                   % &quot;, &quot;.join(
                       [
                           &quot;%s=%s&quot; % (i, repr(f_local[i]))
                           for i in sorted(f_local.keys())
                       ]
                   )
                   if f_local
                   else &quot;()&quot;
               )
           if self not in f_local.values():
               # add self to name space for __del__ way.
               sys._getframe(stack_level).f_locals.update(**{uid: self})
           name = &quot;%s%s&quot; % (f_name, f_vars)
       self.name = name
       self.log_func = log_func
       self.timer = default_timer or timeit.default_timer
       self.rounding = rounding
       self.readable = readable
       self.start_timer = self.timer()
       self._log_after_del = log_after_del
       
   @property
   def string(self):
       &quot;&quot;&quot;Only return the expect_string quietly.&quot;&quot;&quot;
       return self.tick()
       
   @property
   def x(self):
       &quot;&quot;&quot;Call self.log_func(self) and return expect_string.&quot;&quot;&quot;
       self._log_after_del = False
       passed_string = self.string
       if self.log_func:
           self.log_func(self)
       else:
           print_info(
               &quot;Timer [%(passed)s]: %(name)s, start at %(start)s.&quot;
               % (
                   dict(
                       name=self.name, start=ttime(self.start_at), passed=passed_string
                   )
               )
           )
       return passed_string
       
   @property
   def passed(self):
       &quot;&quot;&quot;Return the cost_seconds after starting up.&quot;&quot;&quot;
       return self.timer() - self.start_timer
       
   def tick(self):
       &quot;&quot;&quot;Return the time cost string as expect.&quot;&quot;&quot;
       string = self.passed
       if self.rounding:
           string = round(string)
       if self.readable:
           string = self.readable(string)
       return string
       
   @staticmethod
   def watch(*timer_args, **timer_kwargs):
       &quot;&quot;&quot;Decorator for Timer.&quot;&quot;&quot;
       
       def wrapper(function):
           @wraps(function)
           def inner(*args, **kwargs):
               args1 = &quot;, &quot;.join(map(repr, args)) if args else &quot;&quot;
               kwargs1 = &quot;, &quot;.join(
                   [&quot;%s=%s&quot; % (i, repr(kwargs[i])) for i in sorted(kwargs.keys())]
               )
               arg = &quot;, &quot;.join(filter(None, [args1, kwargs1]))
               name = &quot;%s(%s)&quot; % (function.__name__, arg)
               _ = Timer(name=name, *timer_args, **timer_kwargs)
               result = function(*args, **kwargs)
               return result
       
           return inner
       
       return wrapper
       
   def __del__(self):
       if self._log_after_del:
           # not be called by self.x yet.
           self.x
       
   def __enter__(self):
       return self
       
   def __exit__(self, *args):
       self.x
</code></pre></li>
</ol></li>

<li><p>简简单单的剪贴板辅助工具</p>

<ol>
<li><p>用途很明显, 开启剪贴板 watcher, 会在剪贴板内容发生改变的时候触发 callback</p></li>

<li><p>默认 callback 为原封不动打印内容+换行</p></li>

<li><p>支持异步调用, 即不阻塞主线程.</p>

<pre><code class="language-python">class ClipboardWatcher(object):
   &quot;&quot;&quot;Watch clipboard with `pyperclip`, run callback while changed.&quot;&quot;&quot;
       
   def __init__(self, interval=0.2, callback=None):
       self.pyperclip = try_import(&quot;pyperclip&quot;)
       self.interval = interval
       self.callback = callback or self.default_callback
       self.temp = self.current
       
   def read(self):
       &quot;&quot;&quot;Return the current clipboard content.&quot;&quot;&quot;
       return self.pyperclip.paste()
       
   def write(self, text):
       &quot;&quot;&quot;Rewrite the current clipboard content.&quot;&quot;&quot;
       return self.pyperclip.copy(text)
       
   @property
   def current(self):
       &quot;&quot;&quot;Return the current clipboard content.&quot;&quot;&quot;
       return self.read()
       
   def default_callback(self, text):
       &quot;&quot;&quot;Default clean the \\n in text.&quot;&quot;&quot;
       text = text.replace(&quot;\r\n&quot;, &quot;\n&quot;)
       text = &quot;%s\n&quot; % text
       flush_print(text, sep=&quot;&quot;, end=&quot;&quot;)
       return text
       
   def watch(self, limit=None, timeout=None):
       &quot;&quot;&quot;Block method to watch the clipboard changing.&quot;&quot;&quot;
       start_time = time.time()
       count = 0
       while not timeout or time.time() - start_time &lt; timeout:
           new = self.read()
           if new != self.temp:
               count += 1
               self.callback(new)
               if count == limit:
                   break
           self.temp = new
           time.sleep(self.interval)
       
   @property
   def x(self):
       &quot;&quot;&quot;Return self.watch()&quot;&quot;&quot;
       return self.watch()
       
   @threads(1)
   def watch_async(self, limit=None, timeout=None):
       &quot;&quot;&quot;Non-block method to watch the clipboard changing.&quot;&quot;&quot;
       return self.watch(limit=limit, timeout=timeout)
</code></pre></li>
</ol></li>

<li><p>常用的本地数据持久化功能</p>

<ol>
<li><p>用途很简单, 就是想通过 key value 的方式在本地存放一点数据</p></li>

<li><p>之前我比较习惯用的是 <a href="https://pypi.org/project/sqlitedict/">sqlitedict</a> 这个库, 性能没的说, 不过老得清理 sqlite 缓存 (VACUMM)</p></li>

<li><p>默认路径会放在 Windows / linux 的 User 目录下, 支持 pickle 存储和 json 存储</p></li>

<li><p>早期经常用这个来存储配置文件或者做简单的本地缓存, 现在用的时候少了, 毕竟没解决好多进程的竞态问题</p>

<pre><code class="language-python">class Saver(object):
   &quot;&quot;&quot;
   Simple object persistent toolkit with pickle/json,
   if only you don't care the performance and security.
   **Do not set the key startswith &quot;_&quot;**
       
   :param path: if not set, will be ~/_saver.db. print(self._path) to show it.
       Set pickle's protocol &lt; 3 for compatibility between python2/3,
       but use -1 for performance and some other optimizations.
   :param save_mode: pickle / json.
   &gt;&gt;&gt; ss = Saver()
   &gt;&gt;&gt; ss._path
   '/home/work/_saver.json'
   &gt;&gt;&gt; ss.a = 1
   &gt;&gt;&gt; ss['b'] = 2
   &gt;&gt;&gt; str(ss)
   {'a': 1, 'b': 2, 'c': 3, 'd': 4}
   &gt;&gt;&gt; del ss.b
   &gt;&gt;&gt; str(ss)
   &quot;{'a': 1, 'c': 3, 'd': 4}&quot;
   &gt;&gt;&gt; ss._update({'c': 3, 'd': 4})
   &gt;&gt;&gt; ss
   Saver(path=&quot;/home/work/_saver.json&quot;){'a': 1, 'c': 3, 'd': 4}
   &quot;&quot;&quot;
       
   _instances = {}
   _locks = {}
   _protected_keys = {
       &quot;_auto_backup&quot;,
       &quot;_lock&quot;,
       &quot;_path&quot;,
       &quot;_saver_args&quot;,
       &quot;_save_mode&quot;,
       &quot;_cache&quot;,
       &quot;__getitem__&quot;,
       &quot;_keys&quot;,
       &quot;_values&quot;,
       &quot;__getattr__&quot;,
       &quot;__len__&quot;,
       &quot;_popitem&quot;,
       &quot;_shutdown&quot;,
       &quot;__setitem__&quot;,
       &quot;__delitem__&quot;,
       &quot;_save_obj&quot;,
       &quot;_get&quot;,
       &quot;__dict__&quot;,
       &quot;_clear&quot;,
       &quot;_locks&quot;,
       &quot;__weakref__&quot;,
       &quot;_items&quot;,
       &quot;__module__&quot;,
       &quot;_pop&quot;,
       &quot;__contains__&quot;,
       &quot;_load&quot;,
       &quot;_save&quot;,
       &quot;_update&quot;,
       &quot;_set&quot;,
       &quot;_protected_keys&quot;,
       &quot;_instances&quot;,
       &quot;_get_home_path&quot;,
       &quot;_save_back_up&quot;,
   }
   _protected_keys = _protected_keys | set(object.__dict__.keys())
       
   def __new__(cls, path=None, save_mode=&quot;json&quot;, auto_backup=False, **saver_args):
       # BORG
       path = path or cls._get_home_path(save_mode=save_mode)
       return cls._instances.setdefault(path, super(Saver, cls).__new__(cls))
       
   def __init__(self, path=None, save_mode=&quot;json&quot;, auto_backup=False, **saver_args):
       super(Saver, self).__init__()
       self._auto_backup = auto_backup
       self._lock = self.__class__._locks.setdefault(path, Lock())
       self._path = path or self._get_home_path(save_mode=save_mode)
       self._saver_args = saver_args
       self._save_mode = save_mode
       self._cache = self._load()
       
   @classmethod
   def _get_home_path(cls, save_mode=None):
       home = os.path.expanduser(&quot;~&quot;)
       if save_mode == &quot;json&quot;:
           ext = &quot;json&quot;
       elif save_mode == &quot;pickle&quot;:
           ext = &quot;pkl&quot;
       else:
           ext = &quot;db&quot;
       file_name = &quot;_saver.%s&quot; % ext
       path = os.path.join(home, file_name)
       return path
       
   def _save_back_up(self):
       with open(self._path, &quot;rb&quot;) as f_raw:
           with open(self._path + &quot;.bk&quot;, &quot;wb&quot;) as f_bk:
               f_bk.write(f_raw.read())
       
   def _save_obj(self, obj):
       mode = &quot;wb&quot; if self._save_mode == &quot;pickle&quot; else &quot;w&quot;
       with self._lock:
           with open(self._path, mode) as f:
               if self._save_mode == &quot;json&quot;:
                   json.dump(obj, f, **self._saver_args)
               if self._save_mode == &quot;pickle&quot;:
                   pickle.dump(obj, f, **self._saver_args)
           if self._auto_backup:
               self._save_back_up()
       return obj
       
   def _load(self):
       if not (os.path.isfile(self._path) and os.path.getsize(self._path)):
           cache = {}
           self._save_obj(cache)
           return cache
       mode = &quot;rb&quot; if self._save_mode == &quot;pickle&quot; else &quot;r&quot;
       with self._lock:
           with open(self._path, mode) as f:
               if self._save_mode == &quot;json&quot;:
                   return json.load(f)
               if self._save_mode == &quot;pickle&quot;:
                   return pickle.load(f)
       
   def _save(self):
       return self._save_obj(self._cache)
       
   def _set(self, key, value):
       if self._save_mode == &quot;json&quot;:
           try:
               json.dumps(value)
           except TypeError:
               Config.utils_logger.warning(
                   &quot;Saver._set(%s, %s) failed: bad type, using str(value) instead.&quot;
                   % (key, value)
               )
               value = str(value)
       self._cache[key] = value
       self._save()
       
   def _get(self, key, default=None):
       return self._cache.get(key, default)
       
   def __setattr__(self, key, value):
       if key in self._protected_keys:
           object.__setattr__(self, key, value)
       else:
           self._set(key, value)
       
   def __getattr__(self, key):
       if key in self._protected_keys:
           return object.__getattribute__(self, key)
       return self._get(key)
       
   def __contains__(self, key):
       return key in self._cache
       
   def __delattr__(self, key):
       self._cache.pop(key, None)
       self._save()
       
   def __dir__(self):
       return dir(object)
       
   def __len__(self):
       return len(self._cache)
       
   def _clear(self):
       self._cache = {}
       self._save()
       
   def _shutdown(self):
       if self._auto_backup:
           os.remove(self._path + &quot;.bk&quot;)
       return os.remove(self._path)
       
   def _keys(self):
       return self._cache.keys()
       
   def _items(self):
       return self._cache.items()
       
   def _values(self):
       return self._cache.values()
       
   def _pop(self, key, default=None):
       result = self._cache.pop(key, default)
       self._save()
       return result
       
   def _popitem(self):
       result = self._cache.popitem()
       self._save()
       return result
       
   def _update(self, *args, **kwargs):
       self._cache.update(*args, **kwargs)
       self._save()
       
   def __getitem__(self, key):
       if key in self._cache:
           return self._get(key)
       raise KeyError
       
   def __setitem__(self, key, value):
       self._set(key, value)
       
   def __delitem__(self, key):
       self._cache.pop(key, None)
       self._save()
       
   def __str__(self):
       return str(self._cache)
       
   def __repr__(self):
       return 'Saver(path=&quot;%s&quot;)%s' % (self._path, reprlib.repr(self._cache))
</code></pre></li>
</ol></li>

<li><p>估算一大串无序数字的平均间隔</p>

<ol>
<li><p>当初写这个的使用场景实际是在一万多篇文章的发布时间里, 找出这个作者的发布规律, 因为只是估算个大概, 所以不想导入机器学习相关的第三方库, 就简单实现了一个</p></li>

<li><p>计算方法: 先对序列排序, 然后相邻数字求差, 将差值序列排序取中位数</p>

<pre><code class="language-python">def guess_interval(nums, accuracy=0):
   &quot;&quot;&quot;Given a seq of number, return the median, only calculate interval &gt;= accuracy.
       
   ::
       
       from torequests.utils import guess_interval
       import random
       
       seq = [random.randint(1, 100) for i in range(20)]
       print(guess_interval(seq, 5))
       # sorted_seq: [2, 10, 12, 19, 19, 29, 30, 32, 38, 40, 41, 54, 62, 69, 75, 79, 82, 88, 97, 99]
       # diffs: [8, 7, 10, 6, 13, 8, 7, 6, 6, 9]
       # median: 8
   &quot;&quot;&quot;
   if not nums:
       return 0
   nums = sorted([int(i) for i in nums])
   if len(nums) == 1:
       return nums[0]
   diffs = [nums[i + 1] - nums[i] for i in range(len(nums) - 1)]
   diffs = [item for item in diffs if item &gt;= accuracy]
   sorted_diff = sorted(diffs)
   result = sorted_diff[len(diffs) // 2]
   return result
</code></pre></li>
</ol></li>

<li><p>将字符串按指定方式解析成多维列表</p>

<ol>
<li><p>用的比较少, 用法见 doc 吧</p></li>

<li><p>主要就是把多层 for 循环的代码稍微节省一下</p>

<pre><code class="language-python">import re
       
       
def _re_split_mixin(string, sep, reg=False):
   if reg:
       return re.split(sep, string)
   else:
       return string.split(sep)
       
       
def split_n(string, seps, reg=False):
   r&quot;&quot;&quot;Split strings into n-dimensional list.
       
   ::
       
       from torequests.utils import split_n
       
       ss = '''a b c  d e f  1 2 3  4 5 6
       a b c  d e f  1 2 3  4 5 6
       a b c  d e f  1 2 3  4 5 6'''
       
       print(split_n(ss, ('\n', '  ', ' ')))
       # [[['a', 'b', 'c'], ['d', 'e', 'f'], ['1', '2', '3'], ['4', '5', '6']], [['a', 'b', 'c'], ['d', 'e', 'f'], ['1', '2', '3'], ['4', '5', '6']], [['a', 'b', 'c'], ['d', 'e', 'f'], ['1', '2', '3'], ['4', '5', '6']]]
       print(split_n(ss, ['\s+'], reg=1))
       # ['a', 'b', 'c', 'd', 'e', 'f', '1', '2', '3', '4', '5', '6', 'a', 'b', 'c', 'd', 'e', 'f', '1', '2', '3', '4', '5', '6', 'a', 'b', 'c', 'd', 'e', 'f', '1', '2', '3', '4', '5', '6']
   &quot;&quot;&quot;
   deep = len(seps)
   if not deep:
       return string
   return [split_n(i, seps[1:]) for i in _re_split_mixin(string, seps[0], reg=reg)]
</code></pre></li>
</ol></li>

<li><p>将一个函数丢到后台执行, 并且主线程如果跑完, 不要等这个线程完成就可以结束</p>

<ol>
<li><p>说白了就是将一个同步阻塞的函数, 丢到一个新线程里跑</p></li>

<li><p>默认情况下, 这个现成没跑完, 主线程是无法退出的</p></li>

<li><p>但是如果设置了 Thread.daemon = True, 主线程结束时不需要阻塞等待该线程结束</p></li>

<li><p>这个是有点水&hellip; 还不如 atexit 有用&hellip;</p>

<pre><code class="language-python">def bg(func):
   &quot;&quot;&quot;Run a function in background, will not block main thread's exit.(thread.daemon=True)
   ::
       
       from torequests.utils import bg, print_info
       import time
       
       def test1(n):
           time.sleep(n)
           print_info(n, 'done')
       
       @bg
       def test2(n):
           time.sleep(n)
           print_info(n, 'done')
       
       test3 = bg(test1)
       
       test2(1)
       test3(1)
       print_info('not be blocked')
       time.sleep(2)
       
       # [2018-06-12 23:46:19](L81): not be blocked
       # [2018-06-12 23:46:20](L81): 1 done
       # [2018-06-12 23:46:20](L81): 1 done
   &quot;&quot;&quot;
       
   @wraps(func)
   def wrapper(*args, **kwargs):
       t = Thread(target=func, args=args, kwargs=kwargs)
       # t.daemon = True
       t.start()
       return t
       
   return wrapper
</code></pre></li>
</ol></li>

<li><p>一个简单的倒计时</p>

<ol>
<li><p>正常情况下是阻塞主线程并不换行打印剩余秒数.</p></li>

<li><p>常规用途是在爬虫的两次请求之间显示剩余时间</p>

<pre><code class="language-python">def countdown(
   seconds=None,
   block=True,
   interval=1,
   daemon=True,
   tick_callback=None,
   finish_callback=None,
):
   &quot;&quot;&quot;Run a countdown function to wait something, similar to threading.Timer,
    but will show the detail tick by tick_callback.
    ::
       
       from torequests.utils import countdown
       
       countdown(3)
       # 3 2 1 
       # countdown finished [3 seconds]: 2018-06-13 00:12:55 =&gt; 2018-06-13 00:12:58.
       countdown('2018-06-13 00:13:29')
       # 10 9 8 7 6 5 4 3 2 1 
       # countdown finished [10 seconds]: 2018-06-13 00:13:18 =&gt; 2018-06-13 00:13:28.
&quot;&quot;&quot;
       
   def default_tick_callback(s, seconds, *args):
       flush_print(s, sep=&quot;&quot;, end=&quot; &quot;)
       
   def default_finish_callback(seconds, start_time):
       flush_print()
       
   def cd(seconds, interval):
       for s in range(seconds, 0, -interval):
           tick_callback(s, seconds, interval)
           time.sleep(interval)
       if callable(finish_callback):
           finish_callback(seconds, start_time)
       
   start_time = time.time()
   tick_callback = tick_callback or default_tick_callback
   finish_callback = (
       default_finish_callback if finish_callback is None else finish_callback
   )
       
   if unicode(seconds).isdigit():
       seconds = int(seconds)
   elif isinstance(seconds, (unicode, str)):
       seconds = int(ptime(seconds) - time.time())
   t = Thread(target=cd, args=(seconds, interval))
   t.daemon = daemon
   t.start()
   if block:
       t.join()
</code></pre></li>
</ol></li>

<li><p>乞丐版进度条</p>

<ol>
<li><p>就是想做个不需要太多依赖, 只要稍微看看大体进度</p></li>

<li><p>用法见 Basic Usage</p>

<pre><code class="language-python">def flush_print(*args, **kwargs):
   &quot;&quot;&quot;
   Like print_function at python3, support flush, but not support file.
   :param sep: space by default
   :param end: '\\n' by default
   :param flush: True by default
       
    ::
       
       import time
       from torequests.utils import flush_print
       
       flush_print(&quot;=&quot; * 10)
       for _ in range(10):
           time.sleep(0.2)
           flush_print(&quot;=&quot;, sep=&quot;&quot;, end=&quot;&quot;)
   &quot;&quot;&quot;
   # PY2 raise SyntaxError for : def flush_print(*args, sep='', end=''):
   sep, end, flush = (
       kwargs.pop(&quot;sep&quot;, &quot; &quot;),
       kwargs.pop(&quot;end&quot;, &quot;\n&quot;),
       kwargs.pop(&quot;flush&quot;, 1),
   )
   string = sep.join((unicode(i) for i in args))
   sys.stdout.write(&quot;%s%s&quot; % (string, end))
   if flush:
       sys.stdout.flush()
       
       
class ProgressBar(object):
   &quot;&quot;&quot;Simple progress bar.
       :param size: total counts of calling ProgressBar.x.
       :param length: length of print log.
       :param sig: string of each printing log.
       
   Basic Usage::
       
       pb = ProgressBar(50, 10)
       for _ in range(50):
           time.sleep(0.1)
           pb.x
       print(&quot;current completion rate:&quot;, pb.completion_rate)
       # ==========
       # ==========
       # current completion rate: 1.0
   &quot;&quot;&quot;
       
   def __init__(self, size, length=100, sig=&quot;=&quot;):
       self.size = size or 0
       self.length = length
       self.sig = sig
       self.current = 0
       self.last_print = 0
       self.printed = 0
       if size:
           # use Fraction for the deviation of division
           self.chunk = Fraction(self.size, self.length)
           flush_print(self.sig * self.length)
       else:
           self.chunk = 1
       
   def add(self, step):
       # ensure step &gt;= 0
       self.current += step
       count = int((self.current - self.last_print) / self.chunk)
       if count &lt; 1:
           return self.printed
       for _ in range(count):
           self.printed += 1
           flush_print(self.sig, end=&quot;&quot;)
       self.last_print = count * self.chunk + self.last_print
       if self.current == self.size:
           flush_print()
       return self.printed
       
   @property
   def x(self):
       return self.add(1)
       
   @property
   def completion_rate(self):
       return self.current / self.size
</code></pre></li>
</ol></li>

<li><p>像 JS 那样的正则 match</p>

<ol>
<li><p>也就是匹配到就匹配, 不然就给空字符串, 只要别报错就好</p></li>

<li><p>也可以注册到 re 库里去</p></li>

<li><p>用法见 Basic Usage</p>

<pre><code class="language-python">class RegMatch(object):
   &quot;&quot;&quot;JS-like match object. Use index number to get groups, if not match or no group, will return ''.&quot;&quot;&quot;
       
   def __init__(self, item):
       self.item = item
       
   def __getattr__(self, key, default=null):
       return getattr(self.item, key, default)
       
   def __getitem__(self, index):
       if self.item is None:
           return &quot;&quot;
       if not isinstance(index, int):
           raise IndexError
       try:
           return self.item.group(index)
       except IndexError:
           return &quot;&quot;
       
   @classmethod
   def find_one(cls, pattern, string, flags=0):
       &quot;&quot;&quot;JS-like match object. Use index number to get groups, if not match or no group, will return ''.
       
       Basic Usage::
       
           &gt;&gt;&gt; from torequests.utils import find_one
           &gt;&gt;&gt; string = &quot;abcd&quot;
           &gt;&gt;&gt; find_one(&quot;a.*&quot;, string)
           &lt;torequests.utils.RegMatch object at 0x0705F1D0&gt;
           &gt;&gt;&gt; find_one(&quot;a.*&quot;, string)[0]
           'abcd'
           &gt;&gt;&gt; find_one(&quot;a.*&quot;, string)[1]
           ''
           &gt;&gt;&gt; find_one(&quot;a(.)&quot;, string)[0]
           'ab'
           &gt;&gt;&gt; find_one(&quot;a(.)&quot;, string)[1]
           'b'
           &gt;&gt;&gt; find_one(&quot;a(.)&quot;, string)[2] or &quot;default&quot;
           'default'
           &gt;&gt;&gt; import re
           &gt;&gt;&gt; item = find_one(&quot;a(B)(C)&quot;, string, flags=re.I | re.S)
           &gt;&gt;&gt; item
           &lt;torequests.utils.RegMatch object at 0x0705F1D0&gt;
           &gt;&gt;&gt; item[0]
           'abc'
           &gt;&gt;&gt; item[1]
           'b'
           &gt;&gt;&gt; item[2]
           'c'
           &gt;&gt;&gt; item[3]
           ''
           &gt;&gt;&gt; # import re
           &gt;&gt;&gt; # re.findone = find_one
           &gt;&gt;&gt; register_re_findone()
           &gt;&gt;&gt; re.findone('a(b)', 'abcd')[1] or 'default'
           'b'
       
       &quot;&quot;&quot;
       item = re.search(pattern, string, flags=flags)
       return cls(item)
       
       
def register_re_findone():
   &quot;&quot;&quot;import re; re.findone = find_one&quot;&quot;&quot;
   re.findone = find_one
       
       
find_one = RegMatch.find_one
</code></pre></li>
</ol></li>

<li><p>线程安全的冷却池</p>

<ol>
<li><p>当初为了冷却代理避免反爬做的</p></li>

<li><p>初始化时指定一个 interval, 也就是没冷却够这个秒数的, 无法被取出</p></li>

<li><p>主要依靠的就是默认的 PriorityQueue, 天生线程安全</p></li>

<li><p>为了减少遍历, 所以每次按照上次使用时间来排序, 然后丢到队列里, 即越久未使用越靠前</p></li>

<li><p>队列头部的元素如果距离上次使用时间不超过 interval, 那么就按这个的差值 sleep</p>

<pre><code class="language-python">class TimeItem(object):
   &quot;&quot;&quot;Used for Cooldown.&quot;&quot;&quot;
   __slots__ = ('data', 'use_at')
       
   def __init__(self, data, use_at):
       self.data = data
       self.use_at = use_at
       
   def __hash__(self):
       return hash(self.data)
       
   def __gt__(self, other):
       return self.use_at &gt; other.use_at
       
   def __ge__(self, other):
       return self.use_at &gt;= other.use_at
       
   def __lt__(self, other):
       return self.use_at &lt; other.use_at
       
   def __le__(self, other):
       return self.use_at &lt;= other.use_at
       
   def __eq__(self, other):
       return self.use_at == other.use_at
       
   def __ne__(self, other):
       return self.use_at != other.use_at
       
       
class Cooldown(object):
   &quot;&quot;&quot;Thread-safe Cooldown toolkit.
       
   :param init_items: iterables to add into the default queue at first.
   :param interval: each item will cooldown `interval` seconds before return.
   :param born_at_now: if be set True, the item.use_at will be set time.time()
           instead of 0 when adding to queue at the first time.
       
   &gt;&gt;&gt; from torequests.logs import print_info
   &gt;&gt;&gt; cd = Cooldown(range(1, 3), interval=2)
   &gt;&gt;&gt; cd.add_items([3, 4])
   &gt;&gt;&gt; cd.add_item(5)
   &gt;&gt;&gt; for _ in range(7):
   ...     print_info(cd.get(1, 'timeout'))
   [2019-01-17 01:50:59] pyld.py(152): 1
   [2019-01-17 01:50:59] pyld.py(152): 3
   [2019-01-17 01:50:59] pyld.py(152): 5
   [2019-01-17 01:50:59] pyld.py(152): 2
   [2019-01-17 01:50:59] pyld.py(152): 4
   [2019-01-17 01:51:00] pyld.py(152): timeout
   [2019-01-17 01:51:01] pyld.py(152): 1
   &gt;&gt;&gt; cd.size
   5
   &quot;&quot;&quot;
       
   def __init__(self, init_items=None, interval=0, born_at_now=False):
       self.interval = interval
       self.queue = PriorityQueue()
       self.use_at_function = self.get_now_timestamp if born_at_now else lambda: 0
       self.add_items(init_items or [])
       
   @property
   def size(self):
       return self.queue.qsize()
       
   @property
   def all_items(self):
       return [item.data for item in self.queue.queue]
       
   def get_now_timestamp(self):
       return time.time()
       
   def add_item(self, item):
       if not isinstance(item, TimeItem):
           item = TimeItem(item, self.use_at_function())
       self.queue.put(item)
       
   def add_items(self, items):
       for item in items:
           self.add_item(item)
       
   def remove_item(self, item):
       self.queue.queue = [i for i in self.queue.queue if i.data != item]
       return self.queue.qsize()
       
   def remove_items(self, items):
       self.queue.queue = [i for i in self.queue.queue if i.data in items]
       return self.queue.qsize()
       
   def get(self, timeout=None, default=None):
       try:
           start_time = time.time()
           if timeout is None:
               timeout = float('inf')
           while time.time() - start_time &lt; timeout:
               item = self.queue.get(timeout=timeout)
               if time.time() - item.use_at &lt; self.interval:
                   self.queue.put(item)
                   wait_time = self.interval - (time.time() - item.use_at)
                   wait_time = min((wait_time, timeout))
                   time.sleep(wait_time)
                   continue
               item.use_at = self.get_now_timestamp()
               self.queue.put(item)
               return item.data
           else:
               return default
       except Empty:
           return default
</code></pre></li>
</ol></li>

<li><p>将 python2 和 python3 里常用的解析 URL 的库的名字统一化</p>

<ol>
<li><p>大部分工作其实 requests.compat 都做了</p>

<pre><code class="language-python">if PY2:
   import repr as reprlib
   from Queue import Empty, PriorityQueue
   from urllib import quote, quote_plus, unquote_plus
   from urlparse import (
       parse_qs,
       parse_qsl,
       urlparse,
       unquote,
       urljoin,
       urlsplit,
       urlunparse,
   )
   from cgi import escape
   import HTMLParser
       
   unescape = HTMLParser.HTMLParser().unescape
       
if PY3:
   import reprlib
   from urllib.parse import (
       parse_qs,
       parse_qsl,
       urlparse,
       quote,
       quote_plus,
       unquote,
       unquote_plus,
       urljoin,
       urlsplit,
       urlunparse,
   )
   from html import escape, unescape
   from queue import Empty, PriorityQueue
       
   unicode = str
</code></pre></li>
</ol></li>

<li><p>压力测试 / 检测反爬频率限制</p>

<ol>
<li><p>这个就不多提了, 不太道德, 违反了爬虫<strong>不敲打服务器</strong>的原则, 甚至会因为 dos 获罪</p>

<ol>
<li>但是如果限制参数 n=1, interval=30, 则会变为 30 秒请求一次, 可以用来做连续几天的测试, 通过日志可以发现服务器那边的反爬<strong>安全频率</strong>.</li>
<li>找出安全频率的代码还没写完, 实际上也就是从一个很大的 interval (比如60s) 开始, 每隔一段时间(比如100次请求, 或者一个小时) 将 interval 减少百分之一或者十分之一, 直到触发反爬导致请求结果失败或发生变化.</li>
</ol></li>

<li><p>这个的速度因为要做 md5 等操作, 性能打了很大折扣, 直接使用 torequests.Requests (基于 aiohttp ) 的情况下可以到 1500 qps, golang 原生可以到 6000 qps&hellip;</p>

<pre><code class="language-python">from torequests.crawlers import StressTest
       
StressTest('http://localhost:8080', n=100, timeout=2).x
</code></pre></li>

<li><blockquote>
<p>[2019-10-25 20:12:01] crawlers.py(485): [17496] response: 8389296c-2, start at 2019-10-25 20:11:38 (+00:00:23), 0.131s, 754.92 req/s [100.00 %]
[2019-10-25 20:12:01] crawlers.py(485): [17497] response: 8389296c-2, start at 2019-10-25 20:11:38 (+00:00:23), 0.131s, 754.96 req/s [100.00 %]
[2019-10-25 20:12:01] crawlers.py(485): [17498] response: 8389296c-2, start at 2019-10-25 20:11:38 (+00:00:23), 0.132s, 754.97 req/s [100.00 %]
[2019-10-25 20:12:01] crawlers.py(485): [17499] response: 8389296c-2, start at 2019-10-25 20:11:38 (+00:00:23), 0.132s, 755.02 req/s [100.00 %]
[2019-10-25 20:12:01] crawlers.py(485): [17500] response: 8389296c-2, start at 2019-10-25 20:11:38 (+00:00:23), 0.131s, 755.03 req/s [100.00 %]</p>
</blockquote></li>
</ol></li>

<li><p>净化一个复杂的请求, 只保留最简洁的参数</p>

<ol>
<li><p>这个也不多提了, 实现起来有些脏, 不是很优雅, 虽然还是可以用</p>

<pre><code class="language-python">from torequests.crawlers import CleanRequest
request = '''curl 'https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0' -H 'Pragma: no-cache' -H 'DNT: 1' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: zh-CN,zh;q=0.9' -H 'Upgrade-Insecure-Requests: 1' -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36' -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8' -H 'Cache-Control: no-cache' -H 'Referer: https://p.3.cn?skuIds=1&amp;nonsense=1&amp;nonce=0' -H 'Cookie: ASPSESSIONIDSQRRSADB=MLHDPOPCAMBDGPFGBEEJKLAF' -H 'Connection: keep-alive' --compressed'''
c = CleanRequest(request)
print(c.x)
# {'url': 'https://p.3.cn', 'method': 'get'}
</code></pre></li>
</ol></li>
</ol>

<h2 id="总结">总结</h2>

<p>大部分代码都是学习过程中, 遇到的一些常见问题做的练习, 活到老学到老.</p>

<p>一句话送给喜欢自学的人:</p>

<blockquote>
<p>欲修其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物.</p>

<p>至诚之道, 可以前知.</p>
</blockquote>

        </div>
        

        


        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://clericpy.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="https://github.com/joway/hugo-theme-yinyang" target="_blank">Theme</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://www.clericpy.top/newspaper/articles.query.html" target="_blank">Newspaper</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/ClericPy" target="_blank">Github</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/blog/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  

</body>

</html>